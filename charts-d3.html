<html>
  <head>
    <meta charset="utf-8">
    <title>Perú election explorer</title>
    <style>
      body {
          font: 10px sans-serif;
      }
      svg {
          padding: 10px 0 0 10px;
      }
      .legend {
          vertical-align: top;
      }
      .label {
          text-anchor: middle;
      }
      .label-name {
          font-weight: bold;
      }

    </style>
  </head>
  <body>
    <script src="http://ricilake.github.io/d3.v4.0.0-alpha.15.js" type="text/javascript"></script>
    <script src="http://ricilake.github.io/apportion.js" type="text/javascript"></script>
    <script type="text/javascript">
// variables. These should map to a form somewhere
var method = dhondt; // or sainteLague
var threshold = 0.05;
// TODO: apportionment method
var total_magnitude = 130;
var other_threshold = 0.03; // Parties whose vote is less than this are "other".

var otro = { name: "Otros", colour: "#b0b0b0" };

var radius = d3.scaleSqrt()
    .range([0, 480]);

var pie = d3.pie()
    .sort(null)
    .padAngle(0.02)
    .value(d => d.count);

var arc = d3.arc().padRadius(50);
// TODO: remove otro from the data, or create a new vector every time. Or
// something.

d3.json("cong2016.json", (error, election) => {
  if (error) throw(error);
  data = election.distritos.map(
    distrito => new Vote(distrito[0],
                         election.partidos,
                         distrito[1],
                         distrito[2]))
  // The apportionment rule is "give every constituency one representative
  // and then apportion the rest proportionally." Clearly, that gives a
  // noticeable apportionment bias to the small constituencies.
  // TODO: modify hare to allow for both the freebie and the minimum strategies.
  hare(total_magnitude - data.length, data, "electors", "magnitude")
  data.forEach(v => ++v.magnitude);

  // Sum the votes for all constituencies in order to apply the threshold.
  // Peruvian rules technically require that a complete allocation be
  // without the threshold because the threshold applies to either
  // popular vote or number of elected representatives. The second
  // barrier has never been achieved, and indeed it would be difficult,
  // but really we should do this correctly.
  var total = data.reduce((p,c)=>p.accum(c), new Vote("Total"))
  total.alloc.forEach(a => {
    a.party.allocate = a.count >= total.valid * threshold;
    a.party.isOther = a.count < total.valid * other_threshold;
  });

  data.forEach(v => {
    v.alloc.forEach(a => a.alloc = 0);
    method(v.magnitude, v.alloc.filter(a => a.party.allocate));
    v.alloc.sort((a, b) => a.alloc != b.alloc ? b.alloc - a.alloc
                                              : b.count - a.count);
    v.alloc.forEach(a => {
      if (a.alloc) a.party.isOther = false;
    });
  });

  // Recompute the total so that it contains the sum of the allocations.
  total = data.reduce((p, c) => p.accum(c), new Vote("Perú"));
  total.alloc.sort((a,b) => b.count - a.count);

  // Mark irrelevant parties as "otro"
  var otros = { party: otro, alloc: 0, count: 0 };
  total.alloc.forEach(a => {
    if (a.party.isOther) otros.count += a.count;
  });
  total.alloc.push(otros);
  data.forEach(v => {
    let otros = { party: otro, alloc: 0, count: 0 };
    v.alloc.forEach(a => {
      if (a.party.isOther) otros.count += a.count;
    });
    v.alloc.push(otros);
  });
  data.push(total); data.sort((a,b) => b.valid - a.valid)

  // Now it's time to draw the charts.
  // Based on http://bl.ocks.org/mbostock/4c5fad723c87d2fd8273

  var legendSize = 20, legendPad = 2;

  radius.domain([0, d3.max(data, d => d.valid)]);

  var parties = total.alloc.filter(a => !a.party.isOther);
  var legend = d3.select("body").append("svg")
        .attr("class", "legend")
        .attr("width", 120)
        .attr("height", legendSize * parties.length)
      .selectAll("g")
         .data(parties)
      .enter().append("g")
         .attr("transform", (d, i) => "translate(0," + i * legendSize + ")");
  legend.append("rect")
      .attr("width", legendSize - legendPad)
      .attr("height", legendSize - legendPad)
      .style("fill", d => d.party.colour);

  legend.append("text")
      .attr("x", legendSize + 2 * legendPad)
      .attr("y", (legendSize - legendPad) / 2)
      .attr("dy", ".35em")
      .text(d => d.party.name);

  var svg = d3.select("body").selectAll(".pie")
        .data(data)
      .enter().append("svg")
        .attr("class", "pie")
        .each(multiple)
      .select("g")

  var label = svg.append("text")
      .attr("class", "label");
  label.append("tspan")
      .attr("class", "label-name")
      .attr("x", 0)
      .attr("dy", ".35em")
      .text(d => d.district);

  function multiple(d) {
    var r = radius(d.valid);
    var svg = d3.select(this)
          .attr("width", r * 2)
          .attr("height", r * 2)
        .append("g")
          .attr("transform", "translate(" + r + "," + r + ")");
    svg.selectAll(".arc")
      .data(v => pie(v.alloc.filter(a => !a.party.isOther)))
      .enter().append("path")
        .attr("class", "arc")
        .attr("d", arc.outerRadius(r).innerRadius(r * 0.6))
        .style("fill", a => a.data.party.colour)
  } 
});

    </script> 
  </body>
</html>
